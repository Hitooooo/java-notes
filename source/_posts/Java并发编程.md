---
title: Java并发编程
date: 2020-04-19 23:21:50
categories:
- High Concurrent
tags:
- JavaSE
- Concurrent
---

并发编程的目的是为了让程序运行得更快，但是，并不是启动更多的线程就能让程序最大限度地并发执行。因为存在上下文切换、死锁等问题

<!--more-->

## 并发挑战

1. **多线程不一定快**

    这是因为多线程需要上下文切换的支持，需要一定的资源存储线程切换时地现场信息。 如果数据量较小或计算简单，串行的耗时有可能是小于并发多线程的，那如何解决呢？

   * 无锁编程。多线程处理数据时，可以考虑将数据ID按Hash算法分段取模，不同线程处理不同的数据段。[海量数据处理常见面试题](https://mp.weixin.qq.com/s/rjGqxUvrEqJNlo09GrT1Dw)，失效从有道笔记中找
   * CAS算法。Java的Atomic包使用CAS算法来更新数据，而不需要加锁
   * 协程。在单线程里实现多任务的调度，并在单线程里面维持多个任务的切换。
   * 使用最少线程

2. **死锁处理**

   线程之间因为资源争夺问题，产生的相互等待现象。死锁产生需要四个必要条件

   1. 互斥条件：同一个资源，同一时间只能被一个进程使用
   2. 不可剥夺条件：已经拥有的资源，在使用完毕之前不会被其他线程抢夺
   3. 请求和保持条件：进程在拥有部分所需资源时，还可以继续像系统申请剩下所需的资源
   4. 循环等待条件：在死锁发生时，一定存在这样一个队列。p1等待p2持有的资源，p2等待p3持有的资源...等待p1持有的资源。

   **破坏掉上面的任意一个或多个条件，就可以预防死锁：**

   * 资源互斥是无法改变的特质，无法改变互斥条件
   * 破坏不可剥夺条件：进程只有在所有资源都可用的情况下再去运行，否则处于等待状态。哲学家只有左右都有筷子时，才会拿起筷子并就餐。
   * 破坏请求和保持：进程申请不到所需的资源时，释放自己占用的资源
   *  破坏循环等待：为资源编号，按序申请 。结合MySQL中事务之间产生的死锁及解决办法。[代码参考](https://www.jianshu.com/p/ea718226c56f)

## Java并发底层原理

### Java内存结构

![Java Runtime Aarea](.\Java并发编程\Java Runtime Aarea.png)

**PS：黄色区域为所有线程共享，绿色区域为各个线程独有**

- 堆： Java堆（Java Heap）是Java虚拟机所管理的内存中***最大***的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，***几乎所有的对象实例都在这里分配内存***。 
-  方法区：（Method Area）与Java堆一样，是各个线程共享的内存区域，**它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据**。 
-  运行时常量池： Class文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到常量池中。  运行时常量是相对于常量来说的，它具备一个重要特征是：动态性。当然，值相同的动态常量与我们通常说的常量只是来源不同，但是都是储存在池内同一块内存区域。Java语言并不要求常量一定只能在编译期产生，运行期间也可能产生新的常量，这些常量被放在运行时常量池中。这里所说的常量包括：基本类型包装类 
-  程序计数器：（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。 **可以从微机系统角度的IP指令指针理解，在JVM层面， 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。**
- JVM栈： 与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，**它的生命周期与线程相同**。**虚拟机栈描述的是Java方法执行的内存模型**：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。**每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程**。  
- 本地方法栈： 本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而**本地方法栈则是为虚拟机使用到的Native方法服务**。 

### Java内存模型

Java 线程之间的通信由 Java 内存模型（简称 JMM ）控制，从抽象的⻆度来说，JMM 定义了线程和主内存之间的抽象关系。 JMM 的抽象示意图如图所示：

![](.\Java并发编程\java-volatile-1.png)

- 主存存放线程需要操作的变量，但线程并不直接操作主存。
- 每个线程读取主存变量都是先拷贝一份到工作内存中，不同线程工作内存互不干扰。
- 线程修改了工作内存后，再写回主存中。

### 1.volatile

volatile是一种轻量且在有限的条件下线程安全技术，它保证修饰的变量的可见性和有序性，**但非原子性**。相对于synchronize高效，而常常跟synchronize配合使用。 先来回忆下基本的概念：

1. 内存可见性：指的是线程之间的可见性，当一个线程修改了共享变量时，另一个线程可以读取到这个修改后的值。默认情况下并不是如此，如下图

   ![JMM](.\Java并发编程\java-volatile-1.png)

   - 主存存放线程需要操作的变量，但线程并不直接操作主存。
   - 每个线程读取主存变量都是先拷贝一份到工作内存中，不同线程工作内存互不干扰。
   - 线程修改了工作内存后，再写回主存中。
   - 每次从主存读写的过程都需要经过8原子性操作。 

2. 重排序：为优化程序性能，对原有的指令执⾏顺序进⾏优化重新排序。重排序可能发⽣在多个阶段，⽐如编译重排序、 CPU 重排序等。

3. happens-before规则：

### 2.synchronized






