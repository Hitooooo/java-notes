---
title: MySQL知识点
date: 2020-04-09 00:22:23
categories: 
- database
tags: 
- sql
---

# MySql

## 数据库设计范式

<!--more-->

## 存储引擎

**常见的存储引擎及其区别**

* InnoDB：MySql默认的存储引擎，设计目标是面向在线事务处理的应用。

  * 特点是行锁设计、支持外键；
  * B+索引
  * 通过多版本并发控制来获得高并发性，提供插入缓存、二次写、自适用哈希索引和预读等高可用功能。
  * 并且实现了SQL的四种隔离级别，默认为**REPEATABLE**级别。
  * 对于表中的数据存储使用了聚集(clustered)方式，因此每张表都是按主键的顺序存放，如果没有设置主键，InnoDB会为每一行生成ROWID，并以此作为主键。

  {% asset_img innodb.jpg innodb %} 

* MyISAM：支持全文索引，主要面向查询服务的应用。***MySQL5.7开始InnoDB已经支持全文索引，而且效果更好***

  * 不支持事务。不是所有应用都需要事务支持，只是查询操作。
  * B+索引
  * 表锁设计、**不支持外键**
  * 只缓存索引文件，而不缓存数据文件，这点和大多数数据库都不同

  {% asset_img myisam.jpg innodb %}  

* Memory：表中数据存储在内存中，重启数据全部消失，适合存储临时表，使用Hash索引而不是B+索引。那为什么不使用这个代替Redis？Redis是为了MySQL减负的，而且数据易丢失不保证可用，需要手动持久化。

**InnoDB是如何实现RR（可重复读）的？**



**InnoDB为什么推荐使用自增ID作为主键**

自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。

## 索引

### 数据结构

**二叉查找树**

一棵二叉树中，左子树的键值总是小于根节点，右子树的键值总是大于根节点，因此可以通过中序遍历获取键值的排序输出。但是如果源数列已经是有序的，构建的二叉查找树就会变成高度与数列长度相同的树，查找效率降为o(n)，为此引入平衡二叉树。

**平衡二叉树**

在二叉排序树的基础上，限制树的左右两个子树的**高度差不大于1.**平衡二叉树的查找性能是比较高的，但是最优二叉树的建立和维护需要大量的操作。

**B树**

1.  平衡二叉树节点最多有两个子树，而 B 树每个节点可以有多个子树，M 阶 B 树表示该树每个节点最多有 M 个子树 
2.  平衡二叉树每个节点只有一个数据和两个指向孩子的指针，而 B 树每个中间节点有 k-1 个关键字（可以理解为数据）和 k 个子树 （ k 介于阶数 M 和 M/2 之间，M/2 向上取整 ）
3.  B 树的所有叶子节点都在同一层，并且叶子节点只有关键字，指向孩子的指针为 null 
4.  和平衡二叉树相同的点在于：B 树的节点数据大小也是按照左小右大，子树与节点的大小比较决定了子树指针所处位置 

{% asset_img b-tree.png b-tree %}

   **B 树的每个节点可以表示的信息更多，因此整个树更加“矮胖”，这在从磁盘中查找数据（先读取到内存、后查找）的过程中，可以减少磁盘 IO 的次数，从而提升查找速度** 。

**B+树**

1.  节点的子树数和关键字数相同，（B 树是关键字数比子树数少一）  
2.  节点的关键字表示的是子树中的最大数，在子树中同样含有这个数据。根节点键值就是最大值。B树不允许键重复。
3.  叶子节点包含了全部数据，同时符合左小右大的顺序 

{% asset_img b+tree.png b-tree %}

相较于B树有什么优点？

1. B+中间节点只保存指针，相较于B树中间节点保存指针和记录， 可以大大增加每个节点存储的 key 值的数量，降低 B+ 树的高度。
2. 所有记录都保存在叶子节点，查找效率稳定
3. 叶子节点之间有指针相连，数据遍历时只需要对叶子节点遍历即可，B+非常适合范围查找

**那为什么MongoDB还选择用B树作为索引结构呢？**

综上可以发现B+最大的好处就是范围查找和遍历操作，MongoDB作为非关系型数据库期望单个Collection的设计和查询就能满足需求，不涉及多表操作，如果你的MongoDB频繁使用lookup，那就需要重写审视Collection的设计。MySQL是关系型数据库，很多情况下表与表之间存在很强的关系，**join操作十分常见。**而join操作就不可避免的需要遍历所有记录，而B+树能很好的支持遍历操作。

**[InnoDB索引最左匹配原则]( https://blog.csdn.net/sinat_41917109/article/details/88944290 )**

 索引的底层是一颗B+树，那么联合索引当然还是一颗B+树，只不过联合索引的健值数量不是一个，而是多个。构建一颗B+树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建B+树。
例子：假如创建一个（a,b)的联合索引，那么它的索引树是这样的 

{% asset_img b+tree_keys.png b+tree_keys %}


可以看到a的值是有顺序的，1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。所以b = 2这种查询条件没有办法利用索引，因为联合索引首先是按a排序的，b是无序的。

同时我们还可以发现在a值相等的情况下，b值又是按顺序排列的，但是这种顺序是相对的。所以最左匹配原则遇上范围查询就会停止，剩下的字段都无法使用索引。例如a = 1 and b = 2 a,b字段都可以使用索引，因为在a值确定的情况下b是相对有序的，而a>1and b=2，a字段可以匹配上索引，但b值不可以，因为a的值是一个范围，在这个范围中b是无序的。

最左匹配原则：最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(>、<、between、like)就会停止匹配。

 假如建立联合索引（a,b,c）

```mysql
# 用到了索引 where子句几个搜索条件顺序调换不影响查询结果，因为Mysql中有查询优化器，会自动优化查询顺序
select * from table_name where a = '1' and b = '2' and c = '3' 
select * from table_name where b = '2' and a = '1' and c = '3'
```

```mysql
# 都从最左边开始连续匹配，用到了索引
select * from table_name where a = '1' 
select * from table_name where a = '1' and b = '2'  
select * from table_name where a = '1' and b = '2' and c = '3'
```

```mysql
# 没有从最左边开始，最后查询没有用到索引，用的是全表扫描 
select * from table_name where  b = '2' 
select * from table_name where  c = '3'
select * from table_name where  b = '1' and c = '3' 
```

```mysql
# 不连续时，只用到了a列的索引，b列和c列都没有用到 
select * from table_name where a = '1' and c = '3' 
```

**匹配列前缀**

如果列是字符型的话它的比较规则是先比较字符串的第一个字符，第一个字符小的哪个字符串就比较小，如果两个字符串第一个字符相通，那就再比较第二个字符，第二个字符比较小的那个字符串就比较小，依次类推，比较字符串。

如果a是字符类型，那么前缀匹配用的是索引，后缀和中缀只能全表扫描了

```mysql
select * from table_name where a like 'As%'; //前缀都是排好序的，走索引查询
select * from table_name where  a like '%As'//全表查询
select * from table_name where  a like '%As%'//全表查询
```

 **匹配范围值** 

```mysql
# 可以对最左边的列进行范围查询
select * from table_name where  a > 1 and a < 3
```

```mysql
# 个列同时进行范围查找时，只有对索引最左边的那个列进行范围查找才用到B+树索引，也就是只有a用到索引，在1<a<3的范围内b是无序的，不能用索引，找到1<a<3的记录后，只能根据条件 b > 1继续逐条过滤
select * from table_name where  a > 1 and a < 3 and b > 1;
```

```mysql
# 左边的列是精确查找的，右边的列可以进行范围查找,a=1的情况下b是有序的，进行范围查找走的是联合索引
select * from table_name where  a = 1 and b > 3;
```

 **排序** 

一般情况下，我们只能把记录加载到内存中，再用一些排序算法，比如快速排序，归并排序等在内存中对这些记录进行排序，有时候查询的结果集太大不能在内存中进行排序的话，还可能暂时借助磁盘空间存放中间结果，排序操作完成后再把排好序的结果返回客户端。Mysql中把这种再内存中或磁盘上进行排序的方式统称为文件排序。文件排序非常慢，但如果order子句用到了索引列，就有可能省去文件排序的步骤

```mysql
# b+树索引本身就是按照上述规则排序的，所以可以直接从索引中提取数据，然后进行回表操作取出该索引中不包含的列就好了order by的子句后面的顺序也必须按照索引列的顺序给出，比如
select * from table_name order by a,b,c limit 10;
```

```mysql
# 这种颠倒顺序的没有用到索引
select * from table_name order by b,c,a limit 10;
```

```mysql
# 联合索引左边列为常量，后边的列排序可以用到索引
select * from table_name where a =1 order by b,c limit 10;
```

### 索引类型

索引类型针对的是字段

* FULLTEXT 全文索引，类似倒排索引
* NORMAL  仅加速查询 
* UNIQUE   索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。 
* SPATIAL   对 空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON 

### 索引方法

索引方法即实现索引的方法

* B+树：
* Hash索引，MySQL采用链表法处理Hash冲突。
  *  Hash索引仅仅能满足"=","IN"和"<=>(安全等于)"查询，不能使用范围查询 
  *  Hash索引无法被用来避免数据的排序操作。因为Hash值的大小关系并不一定和Hash运算前的键值完全一样 
  *  Hash索引不能利用部分索引键查询。对于组合索引，Hash索引在计算Hash值的时候是组合索引键合并后再一起计算Hash值，而不是单独计算Hash值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash索引也无法被利用 
  *  Hash索引遇到大量Hash值相等的情况后性能并不一定就会比B+树索引高 

## 锁



## MySQL事务

**事务特性**

事务是访问数据库的一个操作序列，保证了用户的每一次操作都是可靠的，即使出现了异常情况，也不会破坏后台数据的完整性。这就要求事务满足以下四个特性：ACID

* Automic：原子性